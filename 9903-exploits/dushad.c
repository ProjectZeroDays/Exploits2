Greetings,
     Due to the recent outpouring of DU buffer overflows I thought the
following might be of interest. With the Enhanced Security package
running, authentication info is stored in individual files according to
username. In this case /tcb/files/auth/r/root for root and so on. I am not
aware of any built in method for creating the equivalent of your everyday
unix /etc/shadow file. As a result it is probable that many DU systems
have not weeded out poor choices for passwords through the use of a
program such as Crack since each encrypt is stored in a separate file.
     Though trivial once root is compromised, a would be attacker might
have an easy time obtaining passwords because of this "feature". The
program below outputs a crackable shadow file.


 Regards,
  James Clement


----dushad.c----
/*
   Digital Unix 4.x get encrypts from protected password database(s).
   Must be euid(0), compile with cc dushad.c -lsecurity -o dushad
   Written by James Clement - clem7508@fredonia.edu
*/

#include <sys/types.h>
#include <sys/security.h>
#include <prot.h>

struct pr_passwd *getprpwent(void);

void main(){
  struct pr_passwd *p;

  set_auth_parameters();

  while (p = getprpwent())
  {
   printf("%s:%s:%d:::\n", p->ufld.fd_name, p->ufld.fd_encrypt, p->ufld.fd_uid);
  }
}

----end----

--------------------------------------------------------------------------------

Re: Digital Unix 4 protected password database.

Chris Johnson (johnson@ISN.DAC.NEU.EDU)
Tue, 9 Mar 1999 14:52:55 -0500 

On Tue, 9 Mar 1999, James Clement wrote:

> Greetings,
>      Due to the recent outpouring of DU buffer overflows I thought the
> following might be of interest. With the Enhanced Security package
> running, authentication info is stored in individual files according to
> username. In this case /tcb/files/auth/r/root for root and so on. I am not
> aware of any built in method for creating the equivalent of your everyday
> unix /etc/shadow file. As a result it is probable that many DU systems
> have not weeded out poor choices for passwords through the use of a
> program such as Crack since each encrypt is stored in a separate file.
>      Though trivial once root is compromised, a would be attacker might
> have an easy time obtaining passwords because of this "feature". The
> program below outputs a crackable shadow file.
>
>
>  Regards,
>   James Clement
>
>
>

     It WAS primarily stored this way.  Recent versions however
normally store everything in a DBM style file called auth.db unless you
force it otherwise or already are using the separate file approach.

     And as noted, you do need root to run the program.  But if you
are root you don't really need it.  A simple Perl script or even
simpler shell script will do.  Normally the /tcb/files/ tree is owned
by auth.auth and not world readable.  But, um, if you're root all bets
are off anyway.  You don't actually need the passwords.

     Besides, there are uses for the separate file approach.

------------------------------------------------------------------------------
Chris Johnson                  |Internet: johnson@isn.dac.neu.edu
Assistant Director, Systems    |Web:      http://www.dac.neu.edu/dac/c.johnson
Division of Academic Computing |Voice:    617.373.3300
Northeastern University, 39 RI |FAX:      617.373.8600
360 Huntington Ave.            |If ignorance is bliss, why aren't there more
Boston, MA., U.S.A.  02115     |happy people?    Tea bag tag
------------------------------------------------------------------------------

--------------------------------------------------------------------------------

Date: Wed, 10 Mar 1999 09:10:18 -0000
From: Jon Morgan <jmorgan@dircon.co.uk>
To: BUGTRAQ@netspace.org
Subject: Re: Digital Unix 4 protected password database.


>      And as noted, you do need root to run the program.  But if you
> are root you don't really need it.  A simple Perl script or even
> simpler shell script will do.  Normally the /tcb/files/ tree is owned
> by auth.auth and not world readable.  But, um, if you're root all bets
> are off anyway.  You don't actually need the passwords.

The one thing that a lot of people miss with Digital UNIX is that
when you use Enhanced Security in conjunction with NIS, the entire
"protected" password subsystem is available as the NIS map prpasswd.
This contains, amongst other things, the password hash value. Then
your perl or sh script can just harvest these trivially. Why you
want to run a C2 secure system and then use NIS is beyond me, but at
least it gives you nifty password controls...

The one thing that CAN cause problems is that Digital UNIX can use
nonstandard hash algorithms (bigcrypt(), crypt16() and C1crypt()) as
well as the normal crypt(). Not only does this make coding slightly
complicated (as you have to get the correct hash algorithm, but when
a password is created within an Enhanced Security environment that is
over eight characters in length, another password round is created
AFTER the original to contain the rest of the password. This doesn't
make things impossible, just difficult - Digital kindly provide a set
of system calls to do most of this for you.

                -jon.

--
Jon Morgan                                              <jmorgan@dirconspam.co.uk>
Speaking for myself.                     nihil illegitemi carborvndvm
                            ____________________

--------------------------------------------------------------------------------

Date: Wed, 10 Mar 1999 17:36:41 +0000
From: Darren J Moffat - Enterprise Services OS Product Support Group <darren.moffat@uk.sun.com>
To: BUGTRAQ@netspace.org
Subject: Re: Digital Unix 4 protected password database.

>The one thing that a lot of people miss with Digital UNIX is that
>when you use Enhanced Security in conjunction with NIS, the entire
>"protected" password subsystem is available as the NIS map prpasswd.

Just as a clarifiction incase people get confused. This is not an
issue with NIS but with the particular implemention used on Digital UNIX.

Under Solaris there is the option for a passwd.adjunct map which will
stop the display of encrypted passwords for users listed in the adjunct
map when doing a ypcat passwd.


--
Darren J Moffat

--------------------------------------------------------------------------------

Date: Wed, 10 Mar 1999 17:47:36 +0000
From: Alec Muffett <Alec.Muffett@UK.SUN.COM>
To: BUGTRAQ@netspace.org
Subject: Re: Digital Unix 4 protected password database.

>The one thing that CAN cause problems is that Digital UNIX can use
>nonstandard hash algorithms (bigcrypt(), crypt16() and C1crypt()) as
>well as the normal crypt(). Not only does this make coding slightly
>complicated (as you have to get the correct hash algorithm, but when
>a password is created within an Enhanced Security environment that is
>over eight characters in length, another password round is created
>AFTER the original to contain the rest of the password. This doesn't
>make things impossible, just difficult - Digital kindly provide a set
>of system calls to do most of this for you.

Paul Leyland told me, many years ago, that one or more of the
"Enhanced Security" crypt-replacements are actually less secure
than traditional crypt() in many respects.

Consider the:

        crypt first 8 chars
        crypt remaining 8 chars
        join the two ciphertexts

...mechanism; assuming people choose passwords which are (a) plain
dictionary words and (b) only slightly longer than 8 characters, then:

        plaintext = wheatsheaf
        first 8 chars = wheatshe
        last 8 chars = af

...the cracker may brute-force the latter ciphertext with its implicit
small keyspace, and then (eg:) go hunting for words in dictionaries
which are 10 characters long and whose last characters are "af",
thereby possibly reducing the search space for the first 8 characters
*very* significantly.

I attach below a section of an illuminating e-mail of Paul's from 1996;
I do not think he'll mind my publishing it.

I once posted a better algorithm than this (essentially, crypt the
first eight characters "wheatshe", crypt the *last* eight characters
"eatsheaf", remembering to meddle with the salt for the second crypt
by using a function of first plaintext to prevent the pathological
condition where the ciphertext is eight-or-less characters yielding
concatenated repeated ciphertexts... but it never got adopted, and
anyway, MD5 or SHA1 is a much better bet.

There are other issues with the innards of some of these crypt()
replacements, involving numbers of rounds, etc, but it is a long time
since I visited Ultrix and/or them.

        - alec

ps: ObCynic: no doubt some self-aggrandising security research
pseudogroup can easily whip up a PGP-signed "Security Advisory" to
leap on this bandwagon, bring this to the media, and thereby try to
gain credibility.  Don't all jump at once, now, y'hear?



| Here's a test program and it's output when compiled and run under Ultrix
| 4.3a.  Note the behaviour when the password drops below 8 characters...
|
| Paul
|
| 8<---------------------------------------------------------------------->8
|
| main ()
| {
|    printf ("<%s> <%s> <%s>\n", "printf", "aa", crypt16 ("printf", "aa"));
|    printf ("<%s> <%s> <%s>\n", "printf", "AA", crypt16 ("printf", "AA"));
|    printf ("<%s> <%s> <%s>\n", "printf", "az", crypt16 ("printf", "az"));
|    printf ("<%s> <%s> <%s>\n", "printf", "a0", crypt16 ("printf", "a0"));
|    printf ("<%s> <%s> <%s>\n", "LOLOAQICI82QB4IP", "/.", crypt16 ("LOLOAQICI82QB4IP", "/."));
|    printf ("<%s> <%s> <%s>\n", "LOLOAQICI82QB4I", "/.", crypt16 ("LOLOAQICI82QB4I", "/."));
|    printf ("<%s> <%s> <%s>\n", "LOLOAQICI82QB4", "/.", crypt16 ("LOLOAQICI82QB4", "/."));
|    printf ("<%s> <%s> <%s>\n", "LOLOAQICI82QB", "/.", crypt16 ("LOLOAQICI82QB", "/."));
|    printf ("<%s> <%s> <%s>\n", "LOLOAQICI82Q", "/.", crypt16 ("LOLOAQICI82Q", "/."));
|    printf ("<%s> <%s> <%s>\n", "LOLOAQICI82", "/.", crypt16 ("LOLOAQICI82", "/."));
|    printf ("<%s> <%s> <%s>\n", "LOLOAQICI8", "/.", crypt16 ("LOLOAQICI8", "/."));
|    printf ("<%s> <%s> <%s>\n", "LOLOAQICI", "/.", crypt16 ("LOLOAQICI", "/."));
|    printf ("<%s> <%s> <%s>\n", "LOLOAQIC", "/.", crypt16 ("LOLOAQIC", "/."));
|    printf ("<%s> <%s> <%s>\n", "LOLOAQI", "/.", crypt16 ("LOLOAQI", "/."));
|    printf ("<%s> <%s> <%s>\n", "LOLOAQ", "/.", crypt16 ("LOLOAQ", "/."));
|    printf ("<%s> <%s> <%s>\n", "LOLOA", "/.", crypt16 ("LOLOA", "/."));
|    printf ("<%s> <%s> <%s>\n", "LOLO", "/.", crypt16 ("LOLO", "/."));
|    printf ("<%s> <%s> <%s>\n", "LOL", "/.", crypt16 ("LOL", "/."));
|    printf ("<%s> <%s> <%s>\n", "LO", "/.", crypt16 ("LO", "/."));
|    printf ("<%s> <%s> <%s>\n", "L", "/.", crypt16 ("L", "/."));
| }
|
| 8<---------------------------------------------------------------------->8
| <printf> <aa> <aaCjFz4Sh8Eg2QSqAReePlq6>
| <printf> <AA> <AA/xje2RyeiSU0iBY3PDwjYo>
| <printf> <az> <azbLHnWaqbJeQeZc1OSYe7Pk>
| <printf> <a0> <a0yn3KhrcQbus.ioGbPACugk>
| <LOLOAQICI82QB4IP> </.> </.FcK3mad6JwYt8LVmDqz9Lc>
| <LOLOAQICI82QB4I> </.> </.FcK3mad6JwYq1nJWLBmf3E>
| <LOLOAQICI82QB4> </.> </.FcK3mad6JwYy2Cg/eC.S0Y>
| <LOLOAQICI82QB> </.> </.FcK3mad6JwYGluf6Ixbuu6>
| <LOLOAQICI82Q> </.> </.FcK3mad6JwYZpsNag31O/2>
| <LOLOAQICI82> </.> </.FcK3mad6JwYZ5gmSbpOG4c>
| <LOLOAQICI8> </.> </.FcK3mad6JwY0b/Q.wdrEkg>
| <LOLOAQICI> </.> </.FcK3mad6JwYSaRHJoTPzY2>
| <LOLOAQIC> </.> </.FcK3mad6JwYelhbtlysKy6>
| <LOLOAQI> </.> </.HFDmSJe0gdUelhbtlysKy6>
| <LOLOAQ> </.> </.4xr8tFp2YtkelhbtlysKy6>
| <LOLOA> </.> </.J0OjcwfBdmselhbtlysKy6>
| <LOLO> </.> </.W3kA/gJhfNkelhbtlysKy6>
| <LOL> </.> </./8USI4XZojgelhbtlysKy6>
| <LO> </.> </.IsLxNCl59joelhbtlysKy6>
| <L> </.> </.CIu/PzYCkl6elhbtlysKy6>
| 8<---------------------------------------------------------------------->8

--------------------------------------------------------------------------------

Date: Sat, 13 Mar 1999 16:40:55 +0300
From: Solar Designer <solar@FALSE.COM>
To: BUGTRAQ@netspace.org
Subject: Re: Digital Unix 4 protected password database.

Hello,

[ Aleph1, I am not sure if this discussion of old mistakes belongs
here; however, it is useful to learn on them, and I am including a
few facts that I consider funny enough, below. ]

> Paul Leyland told me, many years ago, that one or more of the

He has also posted one implementation based on UFC, to BugTraq in 1995.

> "Enhanced Security" crypt-replacements are actually less secure
> than traditional crypt() in many respects.

Yes.  At least two of them, actually.

The Digital UNIX one (BTW, I've also seen it on a SCO box) works like
this (in pseudo-code):

strcpy(hash, traditional_crypt(pw, salt));
if (strlen(pw) <= 8) return hash;
strcat(hash, traditional_crypt(pw + 8, hash + 2) + 2);
return hash;

(According to an old manpage, this might be extended for longer
passwords as well in reality, but I've never seen those.)

While the Ultrix one is different (and is even less secure):

strcpy(hash, crypt_x20(pw, salt));
strcat(hash, crypt_x5(strlen(pw) > 8 ? pw + 8 : "", salt) + 2);

(Here crypt_xN means the traditional crypt(3) modified to have only
N iterations of DES instead of 25.)

To summarize, the attacks pointed out in previous posts apply to
both; however, it should be noted that for the Digital UNIX one at
least the salts are typically different for the password halves,
and that, on the other hand, even more attacks are possible on the
Ultrix one.

For example, a cracker could work like this:
-- take either the next word or its characters past 8;
for each salt:
-- do 5 iterations of DES, compare against the second halves;
-- do 15 more iterations, compare against the first halves;
-- move to the next salt.

While the Ultrix version always produces 24 character long hashes,
it is still possible to detect if the password is longer than 8
characters or not.  One fast way is to generate a table of second
halves for all the 4096 salts; there's, however, a nicer fast way
that utilizes the properties of DES (namely, the fact that a zero
key is "weak").  The trick is that subsequent DES encryptions with
a zero key undo each other, and thus 5 encryptions are equal to 1.

I am supporting the Digital UNIX (and SCO?) version in John, by
splitting the halves at loading, and combining the cracked ones
back when reporting, thus getting some extra matching salts.

In case this gets to the list, -- is there still any demand for
checking the Ultrix version's passwords, despite the fact that it
would be wiser to switch to a better crypt(3)?  (I've got a few
requests in the past, actually.)

> | <printf> <aa> <aaCjFz4Sh8Eg2QSqAReePlq6>

Checking the pseudo-code above, on a system with extended DES-based
crypt(3) (BSDI, OpenBSD):

$ perl -e 'print crypt("printf", "_I...aa..") . "\n"'
_I...aa..CjFz4Sh8Eg2    <-- got the first half correctly
$ perl -e 'print crypt("", "_3...aa..") . "\n"'
_3...aa..QSqAReePlq6    <-- the second half, 5 iterations
$ perl -e 'print crypt("", "_/...aa..") . "\n"'
_/...aa..QSqAReePlq6    <-- plain DES, no iterations needed

Signed,
Solar Designer

