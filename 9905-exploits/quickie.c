/*
 Quickie Coldfusion exploit finder v1.0

 After seeing all the super lame hacks by groups desperatly seeking media wh0rage, like
 JPs new favorite group, Team spl0it, and all the lame crap they were using, I deciced
 to help them in their quest to look lame. Most of the 'tools' these people were
 releasing were nothing more then modified versions of my cgiscanner (cgiscan.c), so
 here is a newly coded, faster scanner for them to use and rip off. If I find this code,
 like the rest of my code, on JPs code site, with my name cleaverly removed, I am going
 to go take a shit on the hood of his car.

 This should also give McIntyre and Jericho some more sites to put in their hacked site
 archive on attrition.org that JP can rip off to. They have already shit on his car.

 This scanner scans an entire class C address, and does it with no bull. Enter the
 starting IP address, then the one you want to to stop on, and it will scan each box for
 the 3 parts of the bug.

 complies on HP-UX, Linux, *BSD

 to compile:
 luser$ gcc quickie.c -o quickie

 to run:
 luser$ ./quickie 123.123.123.2 123.123.123.254 >> somelog &

 coded by Bronc Buster 
 May 1999

*/


#include <stdio.h>
#include <signal.h>
#include <stdlib.h>
#include <netinet/in.h>
#include <sys/types.h>
#include <sys/socket.h>
/* sets the timeout for connect() - you can change it if you want */
#define TOUT 2 

/*****************************************************/
/* begin eLe3t prototypes                            */
/*****************************************************/

void phalse(int signo);
int connect_time(int sockfd, struct sockaddr *saptr, int salen, int nsec);
void clean(char b[1024]);

/*****************************************************/
/* end eLe3t prototypes                              */
/*****************************************************/

int main(int argc, char **argv)
{

char *temp;
char *ip_ptr;
char buff[1024];   /* who cares, we only want to HTTP header   */
int f1,f2,f3,f4;   /* f1.f2.f3.f4 when we disassemble first IP */
int l1,l2,l3,l4;   /* l1.l2.l3.l4 when we disassemble last IP  */
int i, tmp, n, lame;
int sock;
struct sockaddr_in target;
char *coldf[4];
char *dis[4];

/* this is just for a pretty print */
dis[1] = "openfile.cfm";
dis[2] = "exprcalc.cfm";
dis[3] = "displayopenedfile.cfm";

/* checks for coldfusion bugs */
coldf[1] = "GET /cfdocs/expelval/openfile.cfm HTTP/1.0\n\n";
coldf[2] = "GET /cfdocs/expelval/exprcalc.cfm HTTP/1.0\n\n";
coldf[3] = "GET /cfdocs/expelval/displayopenedfile.cfm HTTP/1.0\n\n";


if(argc<2) exit(printf("\nUsage: %s start_ip ending_ip\n",argv[0]));

printf("\n** A fast coldfusion exploit finder **");
printf("\ncoded by Bronc Buster - May 99\n");

/* parse ripped from HoGs HeaD domain scanner with a little */
/* modification - works good                                */
/* parse first ip - sorry no error checking */
temp=argv[1];
ip_ptr=(char *)strtok(temp,"."); /* get first field and look for . */
f1=atoi(ip_ptr);
ip_ptr=(char *)strtok(NULL,"."); /* null pointer set, get next field */
f2=atoi(ip_ptr);
ip_ptr=(char *)strtok(NULL,"."); /* null pointer set, get next field */
f3=atoi(ip_ptr);
ip_ptr=(char *)strtok(NULL,"."); /* null pointer set, get next field */
f4=atoi(ip_ptr);

/* parse second ip */
temp=argv[2];
ip_ptr=(char *)strtok(temp,"."); /* get first field and look for . */
l1=atoi(ip_ptr);
ip_ptr=(char *)strtok(NULL,"."); /* null pointer set, get next field */
l2=atoi(ip_ptr);
ip_ptr=(char *)strtok(NULL,"."); /* null pointer set, get next field */
l3=atoi(ip_ptr);
ip_ptr=(char *)strtok(NULL,"."); /* null pointer set, get next field */
l4=atoi(ip_ptr);
/* end parsing */

/* class C range checking - morons 'might' use the - hehehe */
if(f4<2 || l4>254)
  exit(printf("IP Numbers out of range\n"));

/* class C only - anyone with a brain can make */
/* this scan class B or A nets - wow kidiez!   */ 
for (i=f4;i<=l4;i++)
  {
  /* reconstruct the IP into a string */
  sprintf(temp,"%d.%d.%d.%d",f1,f2,f3,i);

  bzero(&target,sizeof(target));
  target.sin_addr.s_addr=inet_addr(temp);
  target.sin_family=AF_INET;
  target.sin_port=htons(80); 

/* ok, so this is a lame loop */
  for(lame=1;lame;lame--)
    {
    printf("\nChecking %s:",temp);

/* check for all 3 before we jump for joy */
    for(n=1;n<4;n++)
      {
      sock=socket(AF_INET,SOCK_STREAM,0);
      if(sock<0)
        exit(printf("Error getting socket - socket()\n"));  
      if(connect_time(sock,(struct sockaddr *)&target,sizeof(target),TOUT)==-1)
        {
        close(sock);  
        printf("\n  no HTTPD responce");
        }
      else 
        {
        printf("\n  checking for %s - ",dis[n]);
        send(sock,coldf[n],strlen(coldf[n]),0);
        recv(sock, buff, sizeof(buff),0);
        if(strstr(buff,"200"))
          {
          close(sock);
          clean(buff);
          printf(" FOUND",dis[n]);
          }
        else
          {
          close(sock);
          clean(buff);
          printf(" not found",dis[n]);
          }
        }
      }
    }
  }

printf("\n\nScan finished!\n");
printf("Have fun kiddies!\n");
return 0;

}

/**************************************************************/
/* eLe3t functions                                            */
/**************************************************************/   
/* fake return function for connect_time()  */
void phalse(int signo)
{
return;
}

/* connect with timeout - for speed!@$(*%^@ */
int connect_time(int sockfd, struct sockaddr *saptr, int salen, int nsec)
{
int s;
alarm(0);
signal(SIGALRM,phalse);
alarm(nsec);

if((s=connect(sockfd,(struct sockaddr *)saptr,salen))<0)
  {
  close(sockfd);
  if(errno==EINTR);
  errno=ETIMEDOUT;
  }
alarm(0);
signal(SIGALRM, SIG_DFL);
return (s);
}

/* clean out buffer so we don't get fake readings */
void clean(char b[1024])
{
int i;
for(i=0;i<=strlen(b);i++)
  b[i]=NULL;
}

/* EOF */
